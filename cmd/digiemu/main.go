package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"digiemu-core/internal/httpapi"
	fsrepo "digiemu-core/internal/kernel/adapters/fs"
	mem "digiemu-core/internal/kernel/adapters/memory"
	"digiemu-core/internal/kernel/domain"
	"digiemu-core/internal/kernel/ports"
	usecases "digiemu-core/internal/kernel/usecases"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "meaning":
		runMeaning(os.Args[2:])
	case "claim":
		runClaim(os.Args[2:])
	case "unit":
		runUnit(os.Args[2:])
	case "version":
		runVersion(os.Args[2:])
	case "audit":
		runAudit(os.Args[2:])
	case "export":
		runExport(os.Args[2:])
	case "serve":
		runServe(os.Args[2:])
	case "--help", "-h", "help":
		printUsage()
	default:
		fmt.Fprintf(os.Stderr, "unknown command: %s\n", os.Args[1])
		printUsage()
		os.Exit(2)
	}
}

func printUsage() {
	fmt.Println("digiemu - minimal CLI for digiemu-core")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  digiemu unit create [--key KEY] --title TITLE [--desc DESC|--description DESC] [--data ./data]")
	fmt.Println("  digiemu version create --unit UNIT_KEY --content CONTENT [--data ./data]")
	fmt.Println("  digiemu audit verify [--data ./data] [--strict-hash] [--unit UNIT_KEY]")
	fmt.Println("  digiemu audit tail [--data ./data] [--n 50] [--type EVENT_TYPE] [--unit-id UNIT_ID] [--version-id VERSION_ID] [--json]")
	fmt.Println("  digiemu export unit --unit UNIT_KEY [--data ./data] [--audit] [--pretty]")
	fmt.Println("  digiemu serve [--addr :8080] [--data ./data]")
	fmt.Println("  digiemu meaning set <unitKeyOrId> [--version <versionId>] --file <meaning.json> [--data ./data]")
	fmt.Println("  digiemu meaning show <unitKeyOrId> [--version <versionId>] [--data ./data]")
	fmt.Println("  digiemu claim set <unitKeyOrId> [--version <versionId>] --file <claimset.json> [--data ./data]")
	fmt.Println("  digiemu claim show <unitKeyOrId> [--version <versionId>] [--data ./data]")
}

func runUnit(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}

	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("unit create", flag.ExitOnError)
		key := fs.String("key", "", "unit key (optional, autogenerated from title)")
		title := fs.String("title", "", "unit title (required)")
		desc := fs.String("desc", "", "unit description (optional)")
		description := fs.String("description", "", "unit description (optional, alias for --desc)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *title == "" {
			fmt.Fprintln(os.Stderr, "--title is required")
			fs.Usage()
			os.Exit(2)
		}

		k := *key
		if k == "" {
			k = slugify(*title)
		}

		d := *desc
		if *description != "" {
			d = *description
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		uc := usecases.CreateUnit{Repo: repo, Audit: audit, Clock: clock}

		in := ports.CreateUnitRequest{Key: k, Title: *title, Description: d, ActorID: "cli"}
		out, err := uc.CreateUnit(in)
		if err != nil {
			log.Fatalf("create unit: %v", err)
		}
		fmt.Printf("OK: unit created id=%s key=%s\n", out.UnitID, out.Key)

	default:
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}
}

func runVersion(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}

	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("version create", flag.ExitOnError)
		unit := fs.String("unit", "", "unit key (required)")
		content := fs.String("content", "", "version content (required)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *unit == "" || *content == "" {
			fmt.Fprintln(os.Stderr, "--unit and --content are required")
			fs.Usage()
			os.Exit(2)
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		vc := usecases.CreateVersion{Repo: repo, Audit: audit, Clock: clock}

		// v0.2.3+: milliseconds to reduce collisions
		label := time.Now().UTC().Format("20060102T150405.000Z")

		in := ports.CreateVersionRequest{UnitKey: *unit, Label: label, Content: *content, ActorID: "cli"}
		out, err := vc.CreateVersion(in)
		if err != nil {
			log.Fatalf("create version: %v", err)
		}
		fmt.Printf("OK: version created id=%s unit=%s\n", out.VersionID, out.UnitID)

	default:
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}
}

func runMeaning(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "meaning subcommands: set | show")
		os.Exit(2)
	}

	switch args[0] {
	case "set":
		fs := flag.NewFlagSet("meaning set", flag.ExitOnError)
		version := fs.String("version", "", "version id (optional, defaults to head)")
		file := fs.String("file", "", "path to meaning.json")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *file == "" {
			fmt.Fprintln(os.Stderr, "--file is required")
			fs.Usage()
			os.Exit(2)
		}
		// positional unit key/id
		rem := fs.Args()
		if len(rem) == 0 {
			fmt.Fprintln(os.Stderr, "unit key or id is required")
			fs.Usage()
			os.Exit(2)
		}
		unitKeyOrID := rem[0]

		b, err := os.ReadFile(*file)
		if err != nil {
			log.Fatalf("read file: %v", err)
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		uc := usecases.SetMeaning{Repo: repo, Audit: audit, Clock: clock}
		out, err := uc.SetMeaning(ports.SetMeaningRequest{UnitKey: unitKeyOrID, VersionID: *version, MeaningJSON: b, ActorID: "cli"})
		if err != nil {
			log.Fatalf("set meaning: %v", err)
		}
		fmt.Printf("OK: unit_id=%s version_id=%s meaning_hash=%s\n", out.UnitID, out.VersionID, out.MeaningHash)

	case "show":
		fs := flag.NewFlagSet("meaning show", flag.ExitOnError)
		version := fs.String("version", "", "version id (optional, defaults to head)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		repo := fsrepo.NewUnitRepo(*data)

		rem := fs.Args()
		if len(rem) == 0 {
			fmt.Fprintln(os.Stderr, "unit key or id is required")
			fs.Usage()
			os.Exit(2)
		}
		keyOrID := rem[0]
		var unit domain.Unit
		var ok bool
		var errFind error
		// try by key first
		unit, ok, errFind = repo.FindUnitByKey(keyOrID)
		if errFind != nil {
			log.Fatalf("find unit: %v", errFind)
		}
		if !ok {
			unit, ok, errFind = repo.FindUnitByID(keyOrID)
			if errFind != nil {
				log.Fatalf("find unit by id: %v", errFind)
			}
			if !ok {
				log.Fatalf("unit not found: %s", keyOrID)
			}
		}

		verID := *version
		if verID == "" {
			verID = unit.HeadVersionID
		}
		if verID == "" {
			log.Fatalf("no version specified and unit has no head")
		}

		v, found, err := repo.FindVersionByID(verID)
		if err != nil {
			log.Fatalf("find version: %v", err)
		}
		if !found {
			log.Fatalf("version not found: %s", verID)
		}

		m, ok, err := repo.LoadMeaning(unit.ID, verID)
		if err != nil {
			log.Fatalf("load meaning: %v", err)
		}
		if !ok {
			log.Fatalf("meaning not found for %s %s", unit.ID, verID)
		}

		// pretty print
		jb, _ := json.MarshalIndent(m, "", "  ")
		fmt.Println(string(jb))
		fmt.Printf("meaning_hash=%s\n", v.MeaningHash)

	default:
		fmt.Fprintln(os.Stderr, "meaning subcommands: set | show")
		os.Exit(2)
	}
}

func runClaim(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "claim subcommands: set | show")
		os.Exit(2)
	}

	switch args[0] {
	case "set":
		fs := flag.NewFlagSet("claim set", flag.ExitOnError)
		version := fs.String("version", "", "version id (optional, defaults to head)")
		file := fs.String("file", "", "path to claimset.json")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *file == "" {
			fmt.Fprintln(os.Stderr, "--file is required")
			fs.Usage()
			os.Exit(2)
		}
		rem := fs.Args()
		if len(rem) == 0 {
			fmt.Fprintln(os.Stderr, "unit key or id is required")
			fs.Usage()
			os.Exit(2)
		}
		unitKeyOrID := rem[0]

		b, err := os.ReadFile(*file)
		if err != nil {
			log.Fatalf("read file: %v", err)
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		uc := usecases.SetClaims{Repo: repo, Audit: audit, Clock: clock}
		out, err := uc.SetClaims(ports.SetClaimsRequest{UnitKey: unitKeyOrID, VersionID: *version, BodyBytes: b, ActorID: "cli"})
		if err != nil {
			log.Fatalf("set claims: %v", err)
		}
		fmt.Printf("OK: unit_id=%s version_id=%s claimset_hash=%s\n", out.UnitID, out.VersionID, out.ClaimSetHash)

	case "show":
		fs := flag.NewFlagSet("claim show", flag.ExitOnError)
		version := fs.String("version", "", "version id (optional, defaults to head)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		repo := fsrepo.NewUnitRepo(*data)

		rem := fs.Args()
		if len(rem) == 0 {
			fmt.Fprintln(os.Stderr, "unit key or id is required")
			fs.Usage()
			os.Exit(2)
		}
		keyOrID := rem[0]
		var unit domain.Unit
		var ok bool
		var errFind error
		unit, ok, errFind = repo.FindUnitByKey(keyOrID)
		if errFind != nil {
			log.Fatalf("find unit: %v", errFind)
		}
		if !ok {
			unit, ok, errFind = repo.FindUnitByID(keyOrID)
			if errFind != nil {
				log.Fatalf("find unit by id: %v", errFind)
			}
			if !ok {
				log.Fatalf("unit not found: %s", keyOrID)
			}
		}

		verID := *version
		if verID == "" {
			verID = unit.HeadVersionID
		}
		if verID == "" {
			log.Fatalf("no version specified and unit has no head")
		}

		v, found, err := repo.FindVersionByID(verID)
		if err != nil {
			log.Fatalf("find version: %v", err)
		}
		if !found {
			log.Fatalf("version not found: %s", verID)
		}

		cs, ok, err := repo.LoadClaimSet(unit.ID, verID)
		if err != nil {
			log.Fatalf("load claimset: %v", err)
		}
		if !ok {
			log.Fatalf("claimset not found for %s %s", unit.ID, verID)
		}

		jb, _ := json.MarshalIndent(cs, "", "  ")
		fmt.Println(string(jb))
		fmt.Printf("claimset_hash=%s\n", v.ClaimSetHash)

	default:
		fmt.Fprintln(os.Stderr, "claim subcommands: set | show")
		os.Exit(2)
	}
}

func runAudit(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "audit subcommands: verify | tail")
		os.Exit(2)
	}

	switch args[0] {
	case "verify":
		fs := flag.NewFlagSet("audit verify", flag.ExitOnError)
		data := fs.String("data", "./data", "data directory")
		strictHash := fs.Bool("strict-hash", false, "verify contentHash matches audit events")
		unitKey := fs.String("unit", "", "verify only this unit key")
		fs.Parse(args[1:])

		repo := fsrepo.NewUnitRepo(*data)
		reader := fsrepo.NewAuditReader(*data)

		uc := usecases.VerifyAudit{Repo: repo, Audit: reader}
		out, err := uc.VerifyAudit(ports.VerifyAuditRequest{UnitKey: *unitKey, StrictHash: *strictHash})
		if err != nil {
			log.Fatalf("audit verify: %v", err)
		}

		if out.Ok {
			fmt.Printf("OK: audit verified (units=%d versions=%d)\n", out.TotalUnits, out.TotalVersions)
			return
		}

		fmt.Printf("AUDIT FINDINGS: units=%d versions=%d\n", out.TotalUnits, out.TotalVersions)
		for _, m := range out.Missing {
			if m.EventType == "unit.created" {
				fmt.Printf("MISSING: %s unitId=%s\n", m.EventType, m.UnitID)
			} else {
				fmt.Printf("MISSING: %s unitId=%s versionId=%s\n", m.EventType, m.UnitID, m.VersionID)
			}
		}
		for _, d := range out.Duplicates {
			fmt.Printf("DUPLICATE: %s targetId=%s\n", d.EventType, d.TargetID)
		}
		for _, hm := range out.HashMismatches {
			fmt.Printf("HASH MISMATCH: unitId=%s versionId=%s expected=%s event=%s\n", hm.UnitID, hm.VersionID, hm.ExpectedHash, hm.EventHash)
		}
		os.Exit(1)

	case "tail":
		fs := flag.NewFlagSet("audit tail", flag.ExitOnError)
		data := fs.String("data", "./data", "data directory")
		n := fs.Int("n", 50, "last N matching events")
		typ := fs.String("type", "", "filter by event type (e.g. version.created)")
		unitID := fs.String("unit-id", "", "filter by unit id")
		versionID := fs.String("version-id", "", "filter by version id")
		asJSON := fs.Bool("json", false, "output events as JSON (one per line)")
		fs.Parse(args[1:])

		tail := fsrepo.NewAuditTail(*data)
		evs, err := tail.Tail(ports.AuditTailRequest{N: *n, Type: *typ, UnitID: *unitID, VersionID: *versionID})
		if err != nil {
			log.Fatalf("audit tail: %v", err)
		}

		for _, ev := range evs {
			if *asJSON {
				b, err := json.Marshal(ev)
				if err != nil {
					log.Fatalf("audit tail json: %v", err)
				}
				fmt.Println(string(b))
				continue
			}
			fmt.Printf("%s at=%d actor=%s unit=%s ver=%s id=%s\n", ev.Type, ev.AtUnix, ev.ActorID, ev.UnitID, ev.VersionID, ev.ID)
		}

	default:
		fmt.Fprintln(os.Stderr, "audit subcommands: verify | tail")
		os.Exit(2)
	}
}

func runServe(args []string) {
	fs := flag.NewFlagSet("serve", flag.ExitOnError)
	addr := fs.String("addr", ":8080", "address to bind")
	data := fs.String("data", "./data", "data directory")
	fs.Parse(args)

	repo := fsrepo.NewUnitRepo(*data)

	// Minimal HTTP wiring (no audit in HTTP routes here unless your httpapi already injects it)
	api := httpapi.API{
		Units:   usecases.CreateUnit{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
		Vers:    usecases.CreateVersion{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
		Meaning: usecases.SetMeaning{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
		Claims:  usecases.SetClaims{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
		Repo:    repo,
	}
	handler := httpapi.NewRouter(api)

	srv := &http.Server{
		Addr:         *addr,
		Handler:      handler,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	fmt.Printf("starting server on %s (data=%s)\n", *addr, *data)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("server error: %v", err)
	}

	_ = context.Background()
}

// slugify creates a simple URL-safe key from the title
func slugify(s string) string {
	s = strings.ToLower(strings.TrimSpace(s))
	s = strings.ReplaceAll(s, " ", "-")
	re := regexp.MustCompile(`[^a-z0-9\-]`)
	s = re.ReplaceAllString(s, "")
	if len(s) < 3 {
		s = s + "-1"
	}
	return s
}
