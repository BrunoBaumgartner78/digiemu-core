package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"digiemu-core/internal/httpapi"
	fsrepo "digiemu-core/internal/kernel/adapters/fs"
	mem "digiemu-core/internal/kernel/adapters/memory"
	"digiemu-core/internal/kernel/ports"
	usecases "digiemu-core/internal/kernel/usecases"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "unit":
		runUnit(os.Args[2:])
	case "version":
		runVersion(os.Args[2:])
	case "audit":
		runAudit(os.Args[2:])
	case "export":
		runExport(os.Args[2:])
	case "serve":
		runServe(os.Args[2:])
	case "--help", "-h", "help":
		printUsage()
	default:
		fmt.Fprintf(os.Stderr, "unknown command: %s\n", os.Args[1])
		printUsage()
		os.Exit(2)
	}
}

func printUsage() {
	fmt.Println("digiemu - minimal CLI for digiemu-core")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  digiemu unit create [--key KEY] --title TITLE [--desc DESC|--description DESC] [--data ./data]")
	fmt.Println("  digiemu version create --unit UNIT_KEY --content CONTENT [--data ./data]")
	fmt.Println("  digiemu audit verify [--data ./data] [--strict-hash] [--unit UNIT_KEY]")
	fmt.Println("  digiemu audit tail [--data ./data] [--n 50] [--type EVENT_TYPE] [--unit-id UNIT_ID] [--version-id VERSION_ID] [--json]")
	fmt.Println("  digiemu export unit --unit UNIT_KEY [--data ./data] [--audit] [--pretty]")
	fmt.Println("  digiemu serve [--addr :8080] [--data ./data]")
}

func runUnit(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}

	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("unit create", flag.ExitOnError)
		key := fs.String("key", "", "unit key (optional, autogenerated from title)")
		title := fs.String("title", "", "unit title (required)")
		desc := fs.String("desc", "", "unit description (optional)")
		description := fs.String("description", "", "unit description (optional, alias for --desc)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *title == "" {
			fmt.Fprintln(os.Stderr, "--title is required")
			fs.Usage()
			os.Exit(2)
		}

		k := *key
		if k == "" {
			k = slugify(*title)
		}

		d := *desc
		if *description != "" {
			d = *description
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		uc := usecases.CreateUnit{Repo: repo, Audit: audit, Clock: clock}

		in := ports.CreateUnitRequest{Key: k, Title: *title, Description: d, ActorID: "cli"}
		out, err := uc.CreateUnit(in)
		if err != nil {
			log.Fatalf("create unit: %v", err)
		}
		fmt.Printf("OK: unit created id=%s key=%s\n", out.UnitID, out.Key)

	default:
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}
}

func runVersion(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}

	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("version create", flag.ExitOnError)
		unit := fs.String("unit", "", "unit key (required)")
		content := fs.String("content", "", "version content (required)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *unit == "" || *content == "" {
			fmt.Fprintln(os.Stderr, "--unit and --content are required")
			fs.Usage()
			os.Exit(2)
		}

		repo := fsrepo.NewUnitRepo(*data)
		audit := fsrepo.NewAuditLog(*data)
		clock := mem.RealClock{}

		vc := usecases.CreateVersion{Repo: repo, Audit: audit, Clock: clock}

		// v0.2.3+: milliseconds to reduce collisions
		label := time.Now().UTC().Format("20060102T150405.000Z")

		in := ports.CreateVersionRequest{UnitKey: *unit, Label: label, Content: *content, ActorID: "cli"}
		out, err := vc.CreateVersion(in)
		if err != nil {
			log.Fatalf("create version: %v", err)
		}
		fmt.Printf("OK: version created id=%s unit=%s\n", out.VersionID, out.UnitID)

	default:
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}
}

func runAudit(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "audit subcommands: verify | tail")
		os.Exit(2)
	}

	switch args[0] {
	case "verify":
		fs := flag.NewFlagSet("audit verify", flag.ExitOnError)
		data := fs.String("data", "./data", "data directory")
		strictHash := fs.Bool("strict-hash", false, "verify contentHash matches audit events")
		unitKey := fs.String("unit", "", "verify only this unit key")
		fs.Parse(args[1:])

		repo := fsrepo.NewUnitRepo(*data)
		reader := fsrepo.NewAuditReader(*data)

		uc := usecases.VerifyAudit{Repo: repo, Audit: reader}
		out, err := uc.VerifyAudit(ports.VerifyAuditRequest{UnitKey: *unitKey, StrictHash: *strictHash})
		if err != nil {
			log.Fatalf("audit verify: %v", err)
		}

		if out.Ok {
			fmt.Printf("OK: audit verified (units=%d versions=%d)\n", out.TotalUnits, out.TotalVersions)
			return
		}

		fmt.Printf("AUDIT FINDINGS: units=%d versions=%d\n", out.TotalUnits, out.TotalVersions)
		for _, m := range out.Missing {
			if m.EventType == "unit.created" {
				fmt.Printf("MISSING: %s unitId=%s\n", m.EventType, m.UnitID)
			} else {
				fmt.Printf("MISSING: %s unitId=%s versionId=%s\n", m.EventType, m.UnitID, m.VersionID)
			}
		}
		for _, d := range out.Duplicates {
			fmt.Printf("DUPLICATE: %s targetId=%s\n", d.EventType, d.TargetID)
		}
		for _, hm := range out.HashMismatches {
			fmt.Printf("HASH MISMATCH: unitId=%s versionId=%s expected=%s event=%s\n", hm.UnitID, hm.VersionID, hm.ExpectedHash, hm.EventHash)
		}
		os.Exit(1)

	case "tail":
		fs := flag.NewFlagSet("audit tail", flag.ExitOnError)
		data := fs.String("data", "./data", "data directory")
		n := fs.Int("n", 50, "last N matching events")
		typ := fs.String("type", "", "filter by event type (e.g. version.created)")
		unitID := fs.String("unit-id", "", "filter by unit id")
		versionID := fs.String("version-id", "", "filter by version id")
		asJSON := fs.Bool("json", false, "output events as JSON (one per line)")
		fs.Parse(args[1:])

		tail := fsrepo.NewAuditTail(*data)
		evs, err := tail.Tail(ports.AuditTailRequest{N: *n, Type: *typ, UnitID: *unitID, VersionID: *versionID})
		if err != nil {
			log.Fatalf("audit tail: %v", err)
		}

		for _, ev := range evs {
			if *asJSON {
				b, err := json.Marshal(ev)
				if err != nil {
					log.Fatalf("audit tail json: %v", err)
				}
				fmt.Println(string(b))
				continue
			}
			fmt.Printf("%s at=%d actor=%s unit=%s ver=%s id=%s\n", ev.Type, ev.AtUnix, ev.ActorID, ev.UnitID, ev.VersionID, ev.ID)
		}

	default:
		fmt.Fprintln(os.Stderr, "audit subcommands: verify | tail")
		os.Exit(2)
	}
}

func runServe(args []string) {
	fs := flag.NewFlagSet("serve", flag.ExitOnError)
	addr := fs.String("addr", ":8080", "address to bind")
	data := fs.String("data", "./data", "data directory")
	fs.Parse(args)

	repo := fsrepo.NewUnitRepo(*data)

	// Minimal HTTP wiring (no audit in HTTP routes here unless your httpapi already injects it)
	api := httpapi.API{
		Units: usecases.CreateUnit{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
		Vers:  usecases.CreateVersion{Repo: repo, Audit: fsrepo.NewAuditLog(*data), Clock: mem.RealClock{}},
	}
	handler := httpapi.NewRouter(api)

	srv := &http.Server{
		Addr:         *addr,
		Handler:      handler,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	fmt.Printf("starting server on %s (data=%s)\n", *addr, *data)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("server error: %v", err)
	}

	_ = context.Background()
}

// slugify creates a simple URL-safe key from the title
func slugify(s string) string {
	s = strings.ToLower(strings.TrimSpace(s))
	s = strings.ReplaceAll(s, " ", "-")
	re := regexp.MustCompile(`[^a-z0-9\-]`)
	s = re.ReplaceAllString(s, "")
	if len(s) < 3 {
		s = s + "-1"
	}
	return s
}
