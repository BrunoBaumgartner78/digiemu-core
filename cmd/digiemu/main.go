package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"regexp"
	"strings"
	"time"

	"digiemu-core/internal/httpapi"
	fsrepo "digiemu-core/internal/kernel/adapters/fs"
	"digiemu-core/internal/kernel/ports"
	usecases "digiemu-core/internal/kernel/usecases"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(2)
	}

	switch os.Args[1] {
	case "unit":
		runUnit(os.Args[2:])
	case "version":
		runVersion(os.Args[2:])
	case "serve":
		runServe(os.Args[2:])
	case "--help", "-h", "help":
		printUsage()
	default:
		fmt.Fprintf(os.Stderr, "unknown command: %s\n", os.Args[1])
		printUsage()
		os.Exit(2)
	}
}

func printUsage() {
	fmt.Println("digiemu - minimal CLI for digiemu-core")
	fmt.Println()
	fmt.Println("Usage:")
	fmt.Println("  digiemu unit create [--key KEY] --title TITLE --desc DESC|--description DESC [--data ./data]")
	fmt.Println("  digiemu version create --unit UNIT_KEY --content CONTENT [--data ./data]")
	fmt.Println("  digiemu serve [--addr :8080] [--data ./data]")
}

func runUnit(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}
	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("unit create", flag.ExitOnError)
		key := fs.String("key", "", "unit key (optional, autogenerated from title)")
		title := fs.String("title", "", "unit title (required)")
		desc := fs.String("desc", "", "unit description (optional)")
		description := fs.String("description", "", "unit description (optional, alias for --desc)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *title == "" {
			fmt.Fprintln(os.Stderr, "--title is required")
			fs.Usage()
			os.Exit(2)
		}

		k := *key
		if k == "" {
			k = slugify(*title)
		}

		// prefer long form if present
		d := *desc
		if *description != "" {
			d = *description
		}

		repo := fsrepo.NewUnitRepo(*data)
		uc := usecases.CreateUnit{Repo: repo}

		in := ports.CreateUnitRequest{Key: k, Title: *title, Description: d}
		out, err := uc.CreateUnit(in)
		if err != nil {
			log.Fatalf("create unit: %v", err)
		}
		fmt.Printf("OK: unit created id=%s key=%s\n", out.UnitID, out.Key)
	default:
		fmt.Fprintln(os.Stderr, "unit subcommands: create")
		os.Exit(2)
	}
}

func runVersion(args []string) {
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}
	switch args[0] {
	case "create":
		fs := flag.NewFlagSet("version create", flag.ExitOnError)
		unit := fs.String("unit", "", "unit key (required)")
		content := fs.String("content", "", "version content (required)")
		data := fs.String("data", "./data", "data directory")
		fs.Parse(args[1:])

		if *unit == "" || *content == "" {
			fmt.Fprintln(os.Stderr, "--unit and --content are required")
			fs.Usage()
			os.Exit(2)
		}

		repo := fsrepo.NewUnitRepo(*data)
		vc := usecases.CreateVersion{Repo: repo}
		label := time.Now().UTC().Format("20060102T150405Z")
		in := ports.CreateVersionRequest{UnitKey: *unit, Label: label, Content: *content}
		out, err := vc.CreateVersion(in)
		if err != nil {
			log.Fatalf("create version: %v", err)
		}
		fmt.Printf("OK: version created id=%s unit=%s\n", out.VersionID, out.UnitID)
	default:
		fmt.Fprintln(os.Stderr, "version subcommands: create")
		os.Exit(2)
	}
}

func runServe(args []string) {
	fs := flag.NewFlagSet("serve", flag.ExitOnError)
	addr := fs.String("addr", ":8080", "address to bind")
	data := fs.String("data", "./data", "data directory")
	fs.Parse(args)

	repo := fsrepo.NewUnitRepo(*data)
	api := httpapi.API{Units: usecases.CreateUnit{Repo: repo}, Vers: usecases.CreateVersion{Repo: repo}}
	handler := httpapi.NewRouter(api)

	srv := &http.Server{
		Addr:         *addr,
		Handler:      handler,
		ReadTimeout:  5 * time.Second,
		WriteTimeout: 10 * time.Second,
		IdleTimeout:  120 * time.Second,
	}

	fmt.Printf("starting server on %s (data=%s)\n", *addr, *data)
	if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
		log.Fatalf("server error: %v", err)
	}

	// on graceful shutdown (not implemented here) we'd call srv.Shutdown(ctx)
	_ = context.Background()
}

// slugify creates a simple URL-safe key from the title
func slugify(s string) string {
	s = strings.ToLower(strings.TrimSpace(s))
	// replace spaces with -
	s = strings.ReplaceAll(s, " ", "-")
	// remove chars that are not alnum or -
	re := regexp.MustCompile(`[^a-z0-9\-]`)
	s = re.ReplaceAllString(s, "")
	if len(s) < 3 {
		s = s + "-1"
	}
	return s
}
